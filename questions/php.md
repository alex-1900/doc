# PHP

- [PHP](#PHP)
  - [PHP的生命周期](#PHP的生命周期)
  - [PHP数组的原理](#PHP数组的原理)
  - [PHP的引用原理](#PHP的引用原理)
  - [PHP变量的内存模型](#PHP变量的内存模型)
  - [PHP如何释放循环引用产生的垃圾](#PHP如何释放循环引用产生的垃圾)

### PHP的生命周期
- 模块初始化   
激活 SAPI，初始化请求参数，初始化垃圾回收器，启动 zend 引擎，解析和读取 php.ini 配置信息
- 请求初始化   
CLI 模式没有请求初始化
- 执行脚本
- 请求关闭   
flush输出内容，发送HTTP应答header头，清理全局变量
- 模块关闭   
回调各扩展的 module shutdown 钩子函数。

程序的入口是 sapi 的 main 函数，在 main 函数中创建 sapi_module_struct，绑定钩子函数，然后调用 /main 目录中的公用函数执行。

### PHP数组的原理
php 数组的核心是 hash 表，采用链表法解决 hash 冲突。PHP 数组的原理：元素单独存储在一个有序列表中，另外有一个中间表存储了数组元素在该列表中的下标。PHP 内部具体的实现方法是在初始化列表时额外分配同等长度的 uint32 片段作为索引表，从列表中间位置开始，先向前寻址索引表得到存储表下标，然后向后寻址存储表得到元素值。

当数组空间已满时，插入数组元素的操作就会触发扩容机制，首先检查已删除元素所占比例，比例达到阈值则重建索引和 bucket 链表，未达到阈值则分配一个原数组2倍大小的新数组。然后将原数组的元素复制到新数组上，重建索引（相当于将所有元素重新插入一遍）。

### PHP的引用原理
当使用引用符号`&`赋值时，会为＆操作的变量创建一个 `zend_reference` 结构，这个结构包含原变量的 `zval` 和一个 `gc` 结构体。当另一个变量指向此引用时，`gc` 中的引用计数（gc.refcount）加一。

### PHP变量的内存模型
PHP变量的内存管理思路是：string, array 类型使用`引用计数加写时复制`方式；标量类型和 NULL 使用简单内存模型做深拷贝；object，resource 则无法复制，只能引用。   
- 写时复制原理：   
zend_value 中的子结构都包含 `gc` 结构体，赋值时 首先将变量值的引用指向右值的 zend_value 子结构，然后将 gc 的引用计数加一；当被赋值变量发生改变时，拷贝一份新的值赋给变量，原值的引用计数减一。

### PHP如何释放循环引用产生的垃圾
当一个变量的引用计数减少后大于0，则该变量可能是垃圾，GC 会将这个变量收集起来，在达到一定数量时开始检定和回收垃圾。原理是将 value 的所有内部成员的引用计数减一，结果如果 value 本身的引用计数变成了 0，则表明全部引用来自内部成员，可以进行回收。
